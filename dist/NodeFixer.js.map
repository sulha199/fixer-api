{"version":3,"file":"NodeFixer.js","sourceRoot":"","sources":["../src/NodeFixer.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,mCAA4C;AAC5C,yDAAkD;AAMlD,MAAM,SAAU,SAAQ,aAAK;IAG3B,YAAY,KAAc,EAAE,GAAG,UAAiB;QAC9C,KAAK,CAAC,GAAG,UAAU,CAAC,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAEK,OAAO,CAAS,IAAY,EAAE,IAAgB;;YAClD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC;YAEjE,IAAI,CAAC,SAAS,EAAE;gBACd,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;aACxD;YAED,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CACjD,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,iCAClB,GAAG,GACH,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAClC,EACF;gBACE,UAAU,EAAE,SAAS;aACtB,CACF,CAAC;YAEF,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC;YAElD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,0BAAgB,CAAC,eAAe,CAAC,EAAE,EAAE;gBAC/E,OAAO,EAAE,EAAC,QAAQ,EAAE,SAAS,EAAC;aAC/B,CAAC,CAAC;YAEH,IAAI,YAAY,CAAC;YACjB,IAAI;gBACF,YAAY,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;aACtC;YAAC,WAAM;gBACN,MAAM,IAAI,KAAK,CAAC,cAAc,GAAG,gCAAgC,CAAC,CAAC;aACpE;YAED,IAAI,YAAY,CAAC,KAAK,EAAE;gBACtB,MAAM,IAAI,KAAK,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,IAAI,KAAK,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;aAC3E;YAED,OAAO,YAAY,CAAC;QACtB,CAAC;KAAA;CACF;AAED,kBAAe,SAAS,CAAC","sourcesContent":["import { Fixer, IRawParams } from './Fixer';\r\nimport stringifyOptions from './stringifyOptions';\r\n\r\ntype Fetcher = (...param: Parameters<typeof window.fetch> ) => Promise<{\r\n  readonly json: () => any;\r\n}>;\r\n\r\nclass NodeFixer extends Fixer {\r\n  public fetch: Fetcher;\r\n\r\n  constructor(fetch: Fetcher, ...restParams: any[]) {\r\n    super(...restParams);\r\n    this.fetch = fetch;\r\n  }\r\n\r\n  async request<Result>(path: string, opts: IRawParams): Promise<Result> {\r\n    const accessKey = opts.access_key || this.basicOptions.accessKey;\r\n\r\n    if (!accessKey) {\r\n      throw new Error('access_key is required to use fixer');\r\n    }\r\n\r\n    const filteredOptions = Object.entries(opts).reduce(\r\n      (acc, [key, value]) => ({\r\n        ...acc,\r\n        ...(value ? { [key]: value } : {})\r\n      }),\r\n      {\r\n        access_key: accessKey\r\n      }\r\n    );\r\n\r\n    const url = `${this.basicOptions.baseUrl}${path}`;\r\n   \r\n    const response = await this.fetch(`${url}?${stringifyOptions(filteredOptions)}`, {\r\n      headers: {'apikey': accessKey}\r\n    });\r\n\r\n    let jsonResponse;\r\n    try {\r\n      jsonResponse = await response.json();\r\n    } catch {\r\n      throw new Error(`Request to ${url} resulted in non-JSON response`);\r\n    }\r\n\r\n    if (jsonResponse.error) {\r\n      throw new Error(`${jsonResponse.error.type}: ${jsonResponse.error.info}`);\r\n    }\r\n\r\n    return jsonResponse;\r\n  }\r\n}\r\n\r\nexport default NodeFixer;\r\n"]}